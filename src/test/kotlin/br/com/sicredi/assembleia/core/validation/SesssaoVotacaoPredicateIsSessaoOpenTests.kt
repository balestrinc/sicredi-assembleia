package br.com.sicredi.assembleia.core.validation

import br.com.sicredi.assembleia.core.Clock
import br.com.sicredi.assembleia.core.exception.AssembeiaValidationException
import br.com.sicredi.assembleia.domain.model.SessaoVotacao
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.whenever
import io.kotlintest.shouldBe
import io.kotlintest.shouldThrow
import java.time.LocalDateTime
import org.junit.jupiter.api.Test

internal class SesssaoVotacaoPredicateIsSessaoOpenTests {

    private val clock: Clock = mock()
    private val sessaoVotacaoPredicate = SessaoVotacaoPredicate(clock)

    @Test
    fun `returns true when vote time is between startDateTime and endDateTime`() {

        val currentDateTime = LocalDateTime.now()
        val startDateTime = currentDateTime.minusDays(1)
        val endDateTime = currentDateTime.plusDays(1)

        val openRequest = SessaoVotacao(
            pautaId = 1L,
            startDateTime = startDateTime,
            endDateTime = endDateTime
        )

        whenever(clock.now()).thenReturn(currentDateTime)

        sessaoVotacaoPredicate.isSessaoOpen(openRequest) shouldBe true
    }

    @Test
    fun `returns true when vote time is exactly same as startDateTime`() {

        val currentDateTime = LocalDateTime.parse("2020-01-01T10:50:41")
        val startDateTime = LocalDateTime.parse("2020-01-01T10:50:41")
        val endDateTime = LocalDateTime.parse("2020-01-02T10:50:41")

        val openRequest = SessaoVotacao(
            pautaId = 1L,
            startDateTime = startDateTime,
            endDateTime = endDateTime
        )

        whenever(clock.now()).thenReturn(currentDateTime)

        sessaoVotacaoPredicate.isSessaoOpen(openRequest) shouldBe true
    }

    @Test
    fun `returns true when vote time is exactly same as endDateTime`() {

        val currentDateTime = LocalDateTime.parse("2020-01-02T10:50:41")
        val startDateTime = LocalDateTime.parse("2020-01-01T10:00:00")
        val endDateTime = LocalDateTime.parse("2020-01-02T10:50:41")

        val openRequest = SessaoVotacao(
            pautaId = 1L,
            startDateTime = startDateTime,
            endDateTime = endDateTime
        )

        whenever(clock.now()).thenReturn(currentDateTime)

        sessaoVotacaoPredicate.isSessaoOpen(openRequest) shouldBe true
    }

    @Test
    fun `throws when vote time is before startDateTime`() {

        val currentDateTime = LocalDateTime.now()
        val startDateTime = currentDateTime.plusDays(1)
        val endDateTime = currentDateTime.plusDays(2)

        val openRequest = SessaoVotacao(
            pautaId = 1L,
            startDateTime = startDateTime,
            endDateTime = endDateTime
        )

        whenever(clock.now()).thenReturn(currentDateTime)

        val exception = shouldThrow<AssembeiaValidationException> {
            sessaoVotacaoPredicate.isSessaoOpen(openRequest)
        }
        exception.message shouldBe "Sessão Votação is not open"
    }

    @Test
    fun `throws when vote time is after endDateTime`() {

        val currentDateTime = LocalDateTime.now()
        val startDateTime = currentDateTime.minusDays(3)
        val endDateTime = currentDateTime.minusDays(2)

        val openRequest = SessaoVotacao(
            pautaId = 1L,
            startDateTime = startDateTime,
            endDateTime = endDateTime
        )

        whenever(clock.now()).thenReturn(currentDateTime)

        val exception = shouldThrow<AssembeiaValidationException> {
            sessaoVotacaoPredicate.isSessaoOpen(openRequest)
        }
        exception.message shouldBe "Sessão Votação is not open"
    }

    //
    // @Test
    // fun `returns true when startDatetime is defined but endDateTime is null`() {
    //     val openRequest = SessaoVotacao(
    //         pautaId = 1L,
    //         startDateTime = LocalDateTime.now(),
    //         endDateTime = null
    //     )
    //
    //     sessaoVotacaoPredicate.isPeriodValid(openRequest) shouldBe true
    // }
    //
    // @Test
    // fun `returns true when startDatetime is null and endDateTime is defined`() {
    //     val openRequest = SessaoVotacao(
    //         pautaId = 1L,
    //         startDateTime = null,
    //         endDateTime = LocalDateTime.now()
    //     )
    //
    //     sessaoVotacaoPredicate.isPeriodValid(openRequest) shouldBe true
    // }
    //
    // @Test
    // fun `throws exception when startDatetime is after endDateTime`() {
    //     val now = LocalDateTime.now()
    //     val tomorrow = now.plusDays(1)
    //
    //     val openRequest = SessaoVotacao(
    //         pautaId = 1L,
    //         startDateTime = tomorrow,
    //         endDateTime = now
    //     )
    //
    //     val exception = shouldThrow<AssembeiaValidationException> {
    //         sessaoVotacaoPredicate.isPeriodValid(openRequest)
    //     }
    //     exception.message shouldBe "StartDateTime cannot be bigger than endDateTime"
    // }
}
